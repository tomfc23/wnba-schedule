<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>All Next Games</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 2rem;
    }
    button {
      font-size: 1rem;
      padding: 0.5rem 1rem;
      margin-bottom: 1rem;
    }
    .result {
      margin-top: 1rem;
      padding: 1rem;
      background: #f4f4f4;
      border-radius: 6px;
    }
    h2 {
      margin-top: 2rem;
      font-size: 1.2rem;
      color: #333;
    }
    .game {
      margin: 0.5rem 0;
      padding: 0.5rem;
      background: white;
      border-radius: 4px;
    }
    .matchup {
      font-weight: bold;
    }
    .time {
      color: #666;
      font-size: 0.9rem;
    }
    .error {
      color: red;
      font-style: italic;
    }
    .debug {
      font-size: 0.8rem;
      color: #999;
      margin-top: 0.25rem;
    }
  </style>
</head>
<body>
  <h1>Fetch Next Games for All Sports</h1>
  <button onclick="fetchAllSports()">Fetch All</button>
  <div id="results"></div>
  <script>
    const sports = ['mlb', 'nfl', 'wnba', 'golf', 'ufc']
    const workerURL = 'https://schedule.tommyek67.workers.dev/' // update if needed
    
    function formatGameData(data, sport) {
      console.log(`Processing ${sport} data:`, data);
      
      // Handle different response structures
      let games = [];
      
      if (data && typeof data === 'object') {
        // Check if it's the format with latestDayContent (MLB/NFL)
        if (data.latestDayContent && data.latestDayContent.games) {
          games = data.latestDayContent.games;
        }
        // Check if it's a direct array
        else if (Array.isArray(data)) {
          games = data;
        }
        // Check if it has a games property
        else if (data.games && Array.isArray(data.games)) {
          games = data.games;
        }
        // Check if it has events property (for golf/UFC)
        else if (data.events && Array.isArray(data.events)) {
          games = data.events;
        }
        else {
          console.warn(`Unknown data structure for ${sport}:`, data);
          return 'Unknown data format - check console';
        }
      }
      
      if (!games || games.length === 0) {
        return 'No games found';
      }
      
      return games.map(game => {
        let matchup = '';
        let startTime = '';
        let additionalInfo = '';
        
        // Handle different sports data structures
        if (sport === 'mlb') {
          // MLB specific handling
          const homeTeam = game.homeTeam?.displayName || game.homeTeam?.name || 'Home';
          const awayTeam = game.awayTeam?.displayName || game.awayTeam?.name || 'Away';
          matchup = `${awayTeam} @ ${homeTeam}`;
          startTime = game.dateTime || game.start_time || game.startTime;
          
          // Add record info if available
          if (game.homeWins && game.homeLosses && game.awayWins && game.awayLosses) {
            matchup += ` (${game.awayWins}-${game.awayLosses} @ ${game.homeWins}-${game.homeLosses})`;
          }
        } else if (sport === 'nfl') {
          // NFL specific handling
          const homeTeam = game.homeTeam?.displayName || game.homeTeam?.name || 'Home';
          const awayTeam = game.awayTeam?.displayName || game.awayTeam?.name || 'Away';
          matchup = `${awayTeam} @ ${homeTeam}`;
          startTime = game.dateTime || game.start_time || game.startTime;
          
          // Add season type and channel info
          if (game.seasonType === 'preseason') {
            additionalInfo = 'Preseason';
          }
          if (game.channel) {
            additionalInfo += (additionalInfo ? ' • ' : '') + game.channel;
          }
          if (game.overUnder) {
            additionalInfo += (additionalInfo ? ' • ' : '') + `O/U ${game.overUnder}`;
          }
        } else if (sport === 'golf' || sport === 'ufc') {
          // Golf and UFC have different structures
          if (sport === 'golf') {
            // Golf tournaments have title in metadata
            console.log('Golf game object:', game);
            console.log('Golf metadata exists:', !!game.metadata);
            console.log('Golf metadata:', game.metadata);
            console.log('Golf title from metadata:', game.metadata?.title);
            
            let title = 'Golf Tournament'; // default
            
            // Try multiple ways to access the title
            if (game.metadata && game.metadata.title) {
              title = game.metadata.title;
              console.log('Found title in metadata.title:', title);
            } else if (game.title) {
              title = game.title;
              console.log('Found title in game.title:', title);
            } else if (game.name) {
              title = game.name;
              console.log('Found title in game.name:', title);
            } else {
              console.log('No title found, using default');
            }
            
            const venue = game.metadata?.subtitleFragments?.[0] || '';
            console.log('Venue found:', venue);
            
            matchup = title;
            if (venue) {
              additionalInfo = venue;
            }
            
            console.log('Final golf matchup:', matchup);
            console.log('Final golf additionalInfo:', additionalInfo);
          } else {
            // UFC events
            matchup = game.name || game.title || game.event || game.description || 'UFC Event';
          }
          startTime = game.start_time || game.startTime || game.date || game.dateTime;
        } else {
          // Other team sports (wnba, etc.)
          const homeTeam = game.home_team || game.homeTeam?.displayName || game.homeTeam?.name || game.home || 'Home';
          const awayTeam = game.away_team || game.awayTeam?.displayName || game.awayTeam?.name || game.away || 'Away';
          matchup = `${awayTeam} @ ${homeTeam}`;
          startTime = game.start_time || game.startTime || game.game_time || game.date || game.dateTime;
        }
        
        // Convert time to readable format
        let formattedTime = startTime;
        let debugInfo = '';
        
        try {
          if (startTime && startTime !== 'TBD') {
            const date = new Date(startTime);
            if (!isNaN(date.getTime())) {
              // Format to Eastern Time
              formattedTime = date.toLocaleString('en-US', {
                timeZone: 'America/New_York',
                weekday: 'short',
                month: 'short',
                day: 'numeric',
                hour: 'numeric',
                minute: '2-digit',
                hour12: true
              }) + ' ET';
              
              debugInfo = `Raw: ${startTime}`;
            } else {
              debugInfo = `Invalid date: ${startTime}`;
            }
          }
        } catch (e) {
          console.error('Time conversion error:', e, startTime);
          debugInfo = `Error: ${e.message}`;
        }
        
        return { 
          matchup, 
          time: formattedTime,
          additionalInfo,
          debug: debugInfo,
          rawGame: game // Keep for debugging
        };
      });
    }
    
    async function fetchAllSports() {
      const resultsDiv = document.getElementById('results')
      resultsDiv.innerHTML = 'Loading...'
      
      const fetches = sports.map(async sport => {
        try {
          console.log(`Fetching ${sport}...`);
          const res = await fetch(`${workerURL}/?sport=${sport}&cohort=0`)
          
          if (!res.ok) {
            throw new Error(`HTTP ${res.status}: ${res.statusText}`);
          }
          
          const json = await res.json()
          console.log(`${sport} response:`, json);
          return { sport, data: json }
        } catch (err) {
          console.error(`Error fetching ${sport}:`, err);
          return { sport, error: err.message }
        }
      })
      
      const allResults = await Promise.all(fetches)
      resultsDiv.innerHTML = ''
      
      allResults.forEach(result => {
        const section = document.createElement('div')
        section.className = 'result'
        
        const title = document.createElement('h2')
        title.textContent = result.sport.toUpperCase()
        section.appendChild(title)
        
        if (result.error) {
          const errorDiv = document.createElement('div')
          errorDiv.className = 'error'
          errorDiv.textContent = `Error: ${result.error}`
          section.appendChild(errorDiv)
        } else {
          const games = formatGameData(result.data, result.sport)
          
          if (typeof games === 'string') {
            const noGamesDiv = document.createElement('div')
            noGamesDiv.textContent = games
            section.appendChild(noGamesDiv)
          } else {
            games.forEach(game => {
              const gameDiv = document.createElement('div')
              gameDiv.className = 'game'
              
              const matchupDiv = document.createElement('div')
              matchupDiv.className = 'matchup'
              matchupDiv.textContent = game.matchup
              
              const timeDiv = document.createElement('div')
              timeDiv.className = 'time'
              timeDiv.textContent = game.time
              
              gameDiv.appendChild(matchupDiv)
              gameDiv.appendChild(timeDiv)
              
              // Add additional info if available
              if (game.additionalInfo) {
                const infoDiv = document.createElement('div')
                infoDiv.className = 'time'
                infoDiv.style.fontSize = '0.8rem'
                infoDiv.style.fontStyle = 'italic'
                infoDiv.textContent = game.additionalInfo
                gameDiv.appendChild(infoDiv)
              }
              
              // Add debug info if available
              if (game.debug) {
                const debugDiv = document.createElement('div')
                debugDiv.className = 'debug'
                debugDiv.textContent = game.debug
                gameDiv.appendChild(debugDiv)
              }
              
              section.appendChild(gameDiv)
            })
          }
        }
        
        resultsDiv.appendChild(section)
      })
    }
  </script>
</body>
</html>
